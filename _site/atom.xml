<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>Houkanshan's blog</title>
 <link href="http://houkanshan.github.com/atom.xml" rel="self"/>
 <link href="http://houkanshan.github.com"/>
 <updated>2013-06-10T05:01:02+08:00</updated>
 <id>http://houkanshan.github.com</id>
 <author>
   <name>Hou Kanshan</name>
   <email></email>
 </author>

 
 <entry>
   <title>CSS & HTML 笔记</title>
   <link href="http://houkanshan.github.com/2012/10/30/html-css-mark"/>
   <updated>2012-10-30T00:00:00+08:00</updated>
   <id>http://houkanshan.github.com/2012/10/30/html-css-mark</id>
   <content type="html">&lt;hr /&gt;
&lt;p&gt;There is no emotion, there is peace.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id='html'&gt;HTML&lt;/h2&gt;

&lt;h3 id='quotation_html4'&gt;quotation (HTML4)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;q&amp;gt;&lt;/code&gt; for inline (short) quotations. &lt;br /&gt;&lt;code&gt;&amp;lt;blockquote&amp;gt;&lt;/code&gt; for specifies a section that is quoted from &lt;em&gt;another&lt;/em&gt; source&lt;/p&gt;

&lt;h3 id='fontstyle_html4'&gt;font-style (HTML4)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt; Renders as emphasized text&lt;br /&gt;&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; Defines important text&lt;br /&gt;&lt;code&gt;&amp;lt;dfn&amp;gt;&lt;/code&gt; Defines a definition term&lt;br /&gt;&lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt; Defines a piece of computer code&lt;br /&gt;&lt;code&gt;&amp;lt;samp&amp;gt;&lt;/code&gt; Defines sample output from a computer program&lt;br /&gt;&lt;code&gt;&amp;lt;kbd&amp;gt;&lt;/code&gt; Defines keyboard input&lt;br /&gt;&lt;code&gt;&amp;lt;var&amp;gt;&lt;/code&gt; Defines a variable&lt;br /&gt;&lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; tag can be used to indicate a technical term, a phrase from another language, a thought, or a ship name, etc.&lt;/p&gt;

&lt;p&gt;These Element-style has nothing special except the &lt;strong&gt;font&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id='document_change_html4'&gt;document change (HTML4)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;ins&amp;gt;&lt;/code&gt; tag defines a text that has been inserted into a document.&lt;br /&gt;&lt;code&gt;&amp;lt;del&amp;gt;&lt;/code&gt; tag defines text that has been &lt;strong&gt;deleted(replaced)&lt;/strong&gt; from a document.&lt;br /&gt;&lt;code&gt;&amp;lt;s&amp;gt;&lt;/code&gt; element is redefined in HTML5, and is now used to define text that is &lt;strong&gt;no longer correct&lt;/strong&gt;.(注意del和s的区别)&lt;br /&gt;&lt;code&gt;&amp;lt;mark&amp;gt;&lt;/code&gt; tag defines marked text.&lt;/p&gt;

&lt;h3 id='form'&gt;form&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt; both using &lt;code&gt;for&lt;/code&gt; attribute or just include &lt;code&gt;input&lt;/code&gt; tag will work.&lt;/p&gt;

&lt;h3 id='other_html4'&gt;other HTML4&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;cite&amp;gt;&lt;/code&gt; defines the title of a work &lt;br /&gt;&lt;code&gt;&amp;lt;bdo&amp;gt;&lt;/code&gt; used to override the current text direction.&lt;/p&gt;

&lt;h3 id='other_html5'&gt;other HTML5&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;figcaption&amp;gt;&lt;/code&gt; tag defines a caption for a &lt;code&gt;&amp;lt;figure&amp;gt;&lt;/code&gt; element.&lt;br /&gt;&lt;code&gt;&amp;lt;hgroup&amp;gt;&lt;/code&gt; element is used to group a set of &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; to &lt;code&gt;&amp;lt;h6&amp;gt;&lt;/code&gt; elements, when a heading has multiple levels (subheadings)(主标题\副标题).&lt;br /&gt;&lt;code&gt;&amp;lt;keygen&amp;gt;&lt;/code&gt; tag specifies a key-pair generator field used for forms.(用于不对称加密)&lt;br /&gt;&lt;code&gt;&amp;lt;output&amp;gt;&lt;/code&gt; tag represents the result of a calculation (like one performed by a script). &lt;br /&gt;&lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt; tag defines either a time (24 hour clock), or a date in the Gregorian calendar, optionally with a time and a time-zone offset.&lt;br /&gt;&lt;code&gt;&amp;lt;wbr&amp;gt;&lt;/code&gt; Word Break Opportunity specifies where in a text it would be ok to add a line-break.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id='css'&gt;CSS&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;以下是&lt;em&gt;CSS: The Definition Guide&lt;/em&gt;的读书笔记&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id='48'&gt;第48页&lt;/h3&gt;

&lt;p&gt;属性选择器：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[foo^=&amp;quot;bar&amp;quot;]&lt;/code&gt; bar开头&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[foo$=&amp;quot;bar&amp;quot;]&lt;/code&gt; bar结尾&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[foo*=&amp;quot;bar&amp;quot;]&lt;/code&gt; 有bar字串&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[foo~=&amp;quot;bar&amp;quot;]&lt;/code&gt; 有bar单词&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[foo|=&amp;quot;bar&amp;quot;]&lt;/code&gt; 有bar或者bar-开头&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[foo=&amp;quot;bar&amp;quot;]&lt;/code&gt; 无法选择 &lt;code&gt;&amp;lt;div foo=&amp;quot;bar other&amp;quot;&amp;gt;&lt;/code&gt;,&lt;/p&gt;

&lt;p&gt;\=只能是精确选择 &lt;code&gt;[foo=&amp;quot;bar other&amp;quot;]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;支持： IE6不支持以上的‘子串’选择器&lt;/p&gt;

&lt;p&gt;另：IE6不支持 &amp;gt; 和 + 选择器&lt;/p&gt;
&lt;hr /&gt;
&lt;dl&gt;
&lt;dt&gt;a的伪类：&lt;/dt&gt;

&lt;dd&gt;
&lt;p&gt;link &lt;em&gt;未访问&lt;/em&gt;链接&lt;/p&gt;
&lt;/dd&gt;

&lt;dd&gt;
&lt;p&gt;visited: 访问过链接&lt;/p&gt;
&lt;/dd&gt;

&lt;dd&gt;
&lt;p&gt;focus: 输入焦点&lt;/p&gt;
&lt;/dd&gt;

&lt;dd&gt;
&lt;p&gt;hover: 指针停留&lt;/p&gt;
&lt;/dd&gt;

&lt;dd&gt;
&lt;p&gt;active: 输入激活元素&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;LoveHate 中间插入 focus&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;伪类：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;LoVeHAte, focus, first-child, :lang()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;伪类可结合, &lt;code&gt;:link:hover&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;伪元素：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;first-line, first-letter, before, after&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;伪元素是会创造一个伪的元素并选择，伪类只选择不创造&lt;/p&gt;

&lt;p&gt;伪元素的可用属性是有限的。P67&lt;/p&gt;

&lt;h3 id='76'&gt;第76页&lt;/h3&gt;

&lt;p&gt;应用到body元素的背景样式可以传递到html元素，反向继承了，是特例。&lt;/p&gt;

&lt;p&gt;html没有背景时，body的background被html拿走，body不渲染background。&lt;/p&gt;

&lt;p&gt;字体是会继承的，因此要小心&lt;/p&gt;

&lt;p&gt;&lt;code&gt;body, table, th, td {font-size: .8em}  // 继承bug这里说的不是很清楚 P77&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样的写法，会导致更小的size。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CSS2 中 内联 与 id 同权重。 CSS2.1中，内联在ID后一位(1,0,0,0)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id='99'&gt;第99页&lt;/h3&gt;

&lt;p&gt;inherit是唯一共有的关键字。(但仍不能把他当成默认属性来用)&lt;/p&gt;

&lt;h3 id='110'&gt;第110页&lt;/h3&gt;

&lt;p&gt;bolder是设置一个最接近当前weight的更粗的字体，如果没有更粗，就是最接近的数值(+100至900)，如果weight计算的是200，而下一个weight值是300，那bolder就是300。&lt;/p&gt;

&lt;p&gt;如果200是最粗的了，那么bolder后就是300，且表现没有区别.&lt;/p&gt;

&lt;p&gt;缩放失控：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ul { font-size: .8em; }&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果存在ul的嵌套，就会导致越来越小。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;font-size:&lt;/p&gt;

&lt;p&gt;x-large, xx-large, x-small, xx-small, large, small, medium&lt;/p&gt;

&lt;p&gt;都是绝对的大小，存在一个缩放因子以medium为基准计算大小，&lt;/p&gt;

&lt;p&gt;缩放因子通常是1.5或1.0~1.2&lt;/p&gt;

&lt;p&gt;medium是默认字体大小，浏览器统一，与标签无关。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;font-weight 控制粗细 支持number&lt;/p&gt;

&lt;p&gt;font-style 有normal, italic(斜体), oblique(倾斜文本),&lt;/p&gt;

&lt;p&gt;font-variant 只有一个特殊关键字就是 small-caps -&amp;gt; 小型大写字母&lt;/p&gt;

&lt;p&gt;font-stretch 字体拉伸, 不支持number， 在chrome上测试不支持&lt;/p&gt;

&lt;p&gt;font-size-adjust 当不是首选字体时，乘这个值 / 可用字体的方面值(普遍不支持)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;code&gt;font: [[ &amp;lt;font-style&amp;gt; || &amp;lt;font-variant&amp;gt; || &amp;lt;font-weight&amp;gt;]?&amp;lt;font-size&amp;gt;[/&amp;lt;line-height&amp;gt;]?&amp;lt;font-family&amp;gt;] | caption | icon | menu | message-box | small-caption | status-bar | inherit&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;||&lt;/code&gt; 表示1个或多个&lt;/p&gt;

&lt;p&gt;&lt;code&gt;|&lt;/code&gt; 表示单选&lt;/p&gt;

&lt;p&gt;font-size 相对父元素计算，line-height 相对font-size计算&lt;/p&gt;

&lt;p&gt;直接用font设置时，忽略的属性全会被重置。&lt;/p&gt;

&lt;p&gt;使用后面的caption, icon&amp;#8230;时，会根据用户系统设置应用字体。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;字体匹配：&lt;/p&gt;

&lt;p&gt;1 打开字体数据库&lt;/p&gt;

&lt;p&gt;2 构建字体属性列表，首先选择font-family，根据，如果完全匹配(属性满足)就使用，否则：&lt;/p&gt;

&lt;p&gt;1 首先根据font-style匹配，没有则失败(这个可以计算，应该不会失败)&lt;/p&gt;

&lt;p&gt;2 根据font-variant匹配，应该也不会失败，不支持的浏览器应该会直接忽略(不确定)&lt;/p&gt;

&lt;p&gt;3 根据font-weight匹配，转数字的问题，不会失败&lt;/p&gt;

&lt;p&gt;4 根据font-size匹配，客户端会有一个错误范围的限制&lt;/p&gt;

&lt;p&gt;3 未匹配，就在在font-family中找下一个&lt;/p&gt;

&lt;p&gt;4 找完了还是没有，就搜索另一个候选的font-family&lt;/p&gt;

&lt;p&gt;5 还是没有找到，选择默认字体，使其尽可能正常显示&lt;/p&gt;

&lt;h3 id='136'&gt;第136页&lt;/h3&gt;

&lt;p&gt;text-indent: 内部inline元素首行缩进&lt;/p&gt;

&lt;p&gt;块级元素（显然因为inline是没有宽度的）&lt;/p&gt;

&lt;p&gt;百分比相对于块的宽度计算&lt;/p&gt;

&lt;p&gt;&lt;em&gt;可继承&lt;/em&gt;: 对百分比的处理是，直接继承计算值。而不是百分比值(不会再计算)。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;text-align:&lt;/p&gt;

&lt;p&gt;块级元素（block才有宽度）&lt;/p&gt;

&lt;p&gt;可继承&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;line-height: inline-box的高度&lt;/p&gt;

&lt;p&gt;所有元素:&lt;/p&gt;

&lt;p&gt;百分比相对于font-size计算&lt;/p&gt;

&lt;p&gt;可继承: 对em和百分比将继承计算值，对number将直接继承，也就是会再计算&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;verical-align&lt;/p&gt;

&lt;p&gt;行内元素和 表 单元格&lt;/p&gt;

&lt;p&gt;不可继承&lt;/p&gt;

&lt;p&gt;百分比相对于line-height计算&lt;/p&gt;

&lt;p&gt;baseline: 元素的baseline与父元素的baseline对齐，没有baseline的(图片、表单、其他替换元素)，底端对齐&lt;/p&gt;

&lt;p&gt;sub, super: 相对baseline下降、上升&lt;/p&gt;

&lt;p&gt;bottom: inline-box的底端与line-box底端对齐&lt;/p&gt;

&lt;p&gt;text-bottom: 让bottom只对文本有效，非文本将生成一个由父元素font-size得到的文本框，再底端对齐&lt;/p&gt;

&lt;p&gt;middle: inline-box的中点与父元素baseline上方0.5ex对齐，通常1ex==.5em。准确的应该是x-height的值。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;: baseline(或替换元素的底)与父元素的baseline升高(+)或降低(-) line-height * 百分比&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;length&amp;gt;&lt;/code&gt;: baseline(或替换元素的底)与父元素的baseline升高(+)或降低(-) length&lt;/p&gt;

&lt;p&gt;由&lt;code&gt;&amp;lt;percentage&amp;gt;&amp;lt;length&amp;gt;&lt;/code&gt;设置的对齐会导致line-box的高度变化&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;word-spacing, letter-spacing:&lt;/p&gt;

&lt;p&gt;可继承，将继承计算值，不会再计算&lt;/p&gt;

&lt;p&gt;不能为percentage，因为没有分母&lt;/p&gt;

&lt;p&gt;指定letter-spacing后text-aligin就不会影响letter间隔&lt;/p&gt;

&lt;p&gt;指定了word-spacing还是可能会受text-align的影响(待确定)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;text-transform&lt;/p&gt;

&lt;h3 id='161'&gt;第161页&lt;/h3&gt;

&lt;p&gt;white-space:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;normal              去掉多余的空格，\n换成\s，在边界换行

pre                    \s 不被忽略（空格和回车），边界不换行

nowrap              去掉多余空格，\n换成\s，边界不换行

pre-wrap (2.1)  保留\n, 空格合并, 边界换行

pre-line   (2.1)   \s全保留，边界换行&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;- origin &amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&lt;/p&gt;

&lt;p&gt;normal&lt;/p&gt;

&lt;p&gt;This value directs user agents to collapse sequences of white space, and break lines as necessary to fill line boxes.&lt;/p&gt;

&lt;p&gt;pre&lt;/p&gt;

&lt;p&gt;This value prevents user agents from collapsing sequences of white space. Lines are only broken at preserved newline characters.&lt;/p&gt;

&lt;p&gt;nowrap&lt;/p&gt;

&lt;p&gt;This value collapses white space as for &amp;#8216;normal&amp;#8217;, but suppresses line breaks within text.&lt;/p&gt;

&lt;p&gt;pre-wrap&lt;/p&gt;

&lt;p&gt;This value prevents user agents from collapsing sequences of white space. Lines are broken at preserved newline characters, and as necessary to fill line boxes.&lt;/p&gt;

&lt;p&gt;pre-line&lt;/p&gt;

&lt;p&gt;This value directs user agents to collapse sequences of white space. Lines are broken at preserved newline characters, and as necessary to fill line boxes.&lt;/p&gt;

&lt;h3 id='171'&gt;第171页&lt;/h3&gt;

&lt;p&gt;width, margin-left, margin-right, padding-left, padding-right, border-right, border-left&lt;/p&gt;

&lt;p&gt;他们的计算值必须等于父节点的宽度(margin-right的等级最低)&lt;/p&gt;

&lt;p&gt;对width, margin-left, margin-right:&lt;/p&gt;

&lt;p&gt;0 个 auto:&lt;/p&gt;

&lt;p&gt;如果属性都设置为非auto值，即 overconstrained ，margin-right就会被强制设为auto&lt;/p&gt;

&lt;p&gt;1 个 auto:&lt;/p&gt;

&lt;p&gt;对从左向右读的语言&lt;/p&gt;

&lt;p&gt;margin-left, width, 中有一个设置为auto，其他全为定值，那么auto值将会填充父节点&lt;/p&gt;

&lt;p&gt;2 个 auto:&lt;/p&gt;

&lt;p&gt;2个margin为auto, 居中&lt;/p&gt;

&lt;p&gt;margin+width为auto， width填满，margin为0&lt;/p&gt;

&lt;p&gt;3 个 auto:&lt;/p&gt;

&lt;p&gt;margin为0， width填满&lt;/p&gt;

&lt;p&gt;总之就是：&lt;/p&gt;

&lt;p&gt;margin-left可以定位，&lt;/p&gt;

&lt;p&gt;width会尽量填满，&lt;/p&gt;

&lt;p&gt;margin-right起到约束width的为auto时的填满作用&lt;/p&gt;

&lt;p&gt;（还是不准确）&lt;/p&gt;

&lt;p&gt;margin的percentage是根据width计算的。&lt;/p&gt;

&lt;h3 id='189'&gt;第189页&lt;/h3&gt;

&lt;p&gt;匿名文本：未包含在行内元素中的文本，等价于外部设置了一个虚拟的&lt;code&gt;&amp;lt;line&amp;gt;&lt;/code&gt;标签&lt;/p&gt;

&lt;p&gt;block元素的margin有效，会撑开行框。可见inline-box是不会与内部的margin合并的。&lt;/p&gt;

&lt;p&gt;（注意block在inline是不规范的，这里可以考虑inline-block和img）&lt;/p&gt;

&lt;p&gt;inline的margin-left/right也不会合并&lt;/p&gt;

&lt;p&gt;inline元素不存在margin-top，所以inline的margin无效，inline内的inline即使设置margin，由于无效，所以也撑不开。&lt;/p&gt;

&lt;p&gt;行内框 -&amp;gt; line-height&lt;/p&gt;

&lt;p&gt;内容区 -&amp;gt; font-size&lt;/p&gt;

&lt;p&gt;行间距 -&amp;gt; line-height - font-size / 2 (行间距可以为负数)&lt;/p&gt;

&lt;p&gt;inline-block, img元素的baseline是box的底部(margin-bottom以下)&lt;/p&gt;

&lt;h3 id='270'&gt;第270页&lt;/h3&gt;

&lt;p&gt;background-postion&lt;/p&gt;

&lt;p&gt;定位是相对于padding的内边界，但是内容会延伸到margin的内边界&lt;/p&gt;

&lt;p&gt;两个关键字，水平(left, right)、垂直(top, bottom)，如果出现了一个关键字，则认为另一个是center。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;percentage&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;前水平，后垂直，定位方式为：背景图片的a%, b% 位置与容器区域的a%, b%对齐，造成了0%, 0%在左上角，100%, 100%在右下角(而不是溢出)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;background-attachment:&lt;/p&gt;

&lt;p&gt;scroll (default)&lt;/p&gt;

&lt;p&gt;fixed (注意是相对可视域定位而不是容器)&lt;/p&gt;

&lt;p&gt;inhert&lt;/p&gt;

&lt;h3 id='291'&gt;第291页&lt;/h3&gt;

&lt;p&gt;浮动一个‘简单的’非替换元素，必须有width，否则默认会压缩元素使之 -&amp;gt; 0&lt;/p&gt;

&lt;p&gt;规则：&lt;/p&gt;

&lt;p&gt;1 浮动元素的top不能超出&lt;/p&gt;

&lt;p&gt;2 float:left的left不成超出left，float:right的right不能超出right&lt;/p&gt;

&lt;p&gt;3 浮动元素之间不能重合（BFC）&lt;/p&gt;

&lt;p&gt;4 浮动元素的顶端不能比之前所有浮动元素或者block元素的顶端更高(浮动元素也会形成行框，可以假设这个行框是0高的)（这条就造成ABC，AB左浮，C右浮，B换行了，C不能与A同高）&lt;/p&gt;

&lt;p&gt;5 浮动元素不能超出之前包含浮动元素的行框的顶端，（即浮动元素不会堆到段落上面，同时文本不能完全被浮动元素挤掉，否则浮动元素就得挤到下一行）。&lt;/p&gt;

&lt;p&gt;6 尽可能高&lt;/p&gt;

&lt;p&gt;7 尽可能浮left/right&lt;/p&gt;

&lt;p&gt;(6,7主要对换行，通常的行为是，垂直位置先挤到下一行，低于前一个浮动，水平位置上再向左/右平移，不能再上移/下移)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;不可滥用浮动&lt;/p&gt;

&lt;h3 id='301'&gt;第301页&lt;/h3&gt;

&lt;p&gt;float + 负margin&lt;/p&gt;

&lt;p&gt;对文档中文本产生的效果不确定。(待测试)&lt;/p&gt;

&lt;h3 id='302'&gt;第302页&lt;/h3&gt;

&lt;p&gt;浮动元素在满足规则的情况下重叠时：&lt;/p&gt;

&lt;p&gt;1 inline-box 与 float 重叠， border, text, background 在 float 之上&lt;/p&gt;

&lt;p&gt;2 box 与 float 重叠，border, background 在 float 之下， text 在之上&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;clear&lt;/p&gt;

&lt;p&gt;引入一个清除区域(clearance), 来排斥浮动元素&lt;/p&gt;

&lt;h3 id='309'&gt;第309页&lt;/h3&gt;

&lt;p&gt;relative的containing block还是原来的block，它是相对自己的&lt;/p&gt;

&lt;p&gt;absolute的containing block是相对于最近的absolute，relative父节点，或者根&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;absolute是相对于内容区，不相对padding&lt;/p&gt;

&lt;h3 id='327'&gt;第327页&lt;/h3&gt;

&lt;p&gt;top / bottom / left / right :&lt;/p&gt;

&lt;p&gt;auto 元素的这个属性会保持static状态的值(优先级更低，比如left: auto, right: 1px, 那就是到右边了，left: auto, right: auto就是保持原位了)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;left + margin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right + right = ContainingBlockWidth&lt;/p&gt;

&lt;p&gt;&lt;img alt='width' src='https://docs.google.com/drawings/pub?id=13E7NLY3v93cEOLr3JSYdMz-4KmtdXYYfK3CSQQ4y-rE&amp;amp;w=1440&amp;amp;h=700' /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;如果left, width, right均为auto，那么会得到左边界原位，width收缩到合适。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;如果，left, right, width均为定值(必须满足, 否则还是定位)，那么margin: 0 auto;的时候可以居中。(abosolute会形成块级元素，relative不会)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;如果，left, right同时不为auto，则将left优先。（过度受限）&lt;/p&gt;

&lt;p&gt;如果left，margin-left同时有，将会在基础上算margin，参见上面的公式。&lt;/p&gt;

&lt;p&gt;如果left, margin-right同时有，将不会增加margin，因为right是auto的(或者过度受限)&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;垂直定位方式与水平类似。&lt;/p&gt;

&lt;p&gt;而且由于脱离了文档流(相当于拥有了独立的垂直空间，与水平情况下的block元素类似)可以用margin: auto 0;来居中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.vertical-center {

  position: absolute;

  top: 0;  // not auto

  bottom: 0; // not auto

  margin: auto 0;

}&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;对于可替换元素，区别就在于他的height和width在auto的情况下是默认为原始大小的。&lt;/p&gt;

&lt;p&gt;（对于block而言，width: auto会使他填满区域）&lt;/p&gt;

&lt;p&gt;所以可以直接margin: 0 auto来居中，不需要设置width。&lt;/p&gt;

&lt;p&gt;在absolute的情况下，也可以直接margin: auto 0;来垂直居中。&lt;/p&gt;

&lt;p&gt;（垂直下，对于非替换元素，top/bottom: 非auto会拉伸height，再看下面规则）&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;非替换元素&lt;/p&gt;

&lt;p&gt;如果width/height为auto，他们的长度会尽量填充(优先级低于margin, padding, left/right, 他会被他们压缩)&lt;/p&gt;

&lt;p&gt;对替换元素&lt;/p&gt;

&lt;p&gt;如果width/height为auto，他们的长度会为初始长度(不会尽量拉伸)&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id='338'&gt;第338页&lt;/h3&gt;

&lt;p&gt;z-index:&lt;/p&gt;

&lt;p&gt;relative，absolute都有 CSS3中有opacity，&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;auto: 不建立新的层叠上下文(z-index:0)，与父级相同。&lt;/p&gt;

&lt;p&gt;非auto: 指定了z-index就会创建&lt;em&gt;自己的&lt;/em&gt;叠放上下文。所有子元素设置的z-index都将会在这个z-index级别内。就是9, -100， 8, 1; 这样的东西的结果是9里面的-100就是在8里面的1上面~&lt;/p&gt;

&lt;p&gt;另外，如果两个相同stacking context内的元素设置了相同的z-index, 由于他们都创建了各自的 stacking context 子元素的z-index也不可相互比较。这个时候的排列是由低优先级的html内元素出现 的先后顺序确定的。 即&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#a .child-a: 1, 10
#b .child-b: 1, 2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;的表现为#b和.child-b都在#a和.child-a之上&lt;/p&gt;

&lt;p&gt;对于body下的z-index, 因为body不会创建叠放上下文，且z-index:0, 那么如果一个z-index: -1; 就应该会在body之下。同时由于2.1要求：元素不会叠放在其叠放上下文的背景之下。&lt;/p&gt;

&lt;p&gt;注意：&lt;/p&gt;

&lt;p&gt;&lt;a href='http://www.w3.org/TR/CSS2/visuren.html#z-index'&gt;http://www.w3.org/TR/CSS2/visuren.html#z-index&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The root element forms the root stacking context. Other stacking contexts are generated by any positioned element (including relatively positioned elements) having a computed value of &amp;#8216;z-index&amp;#8217; other than &amp;#8216;auto&amp;#8217;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href='http://www.w3.org/TR/CSS2/colors.html#background-properties'&gt;http://www.w3.org/TR/CSS2/visuren.html#z-index&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;user agents must instead use the computed value of the background properties from that element&amp;#8217;s first HTML &amp;#8220;BODY&amp;#8221; element or XHTML &amp;#8220;body&amp;#8221; element child when painting backgrounds for the canvas, and must not paint a background for that child element.&lt;/p&gt;

&lt;p&gt;情况是由于body设置的background被html拿去了，而body没有了。而html作为root element存在一个stacking context，因此这时z-index: -1000是不会被遮盖的(实际上在body后面)。&lt;/p&gt;

&lt;p&gt;而如果同时设置了body和html的background，那么z-index: -1000就会被body的background挡住了！&lt;/p&gt;

&lt;p&gt;另外，elem.offsetParent 也是针对stacking context的，elem的offsetParrent是它当前的 stacking context, 不过例外是普通元素的offsetParent是BODY而不是HTML&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;好乱。。。就自己看吧。。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>动态配置的CSS</title>
   <link href="http://houkanshan.github.com/2012/10/09/dynamic-configuration-of-css"/>
   <updated>2012-10-09T00:00:00+08:00</updated>
   <id>http://houkanshan.github.com/2012/10/09/dynamic-configuration-of-css</id>
   <content type="html">&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;There is no ignorance, there is knowledge.&lt;/em&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;CSS应该是作为一种配置文件存在的，对HTML而言就是显示样式的配置。 其实上次听讲座也听到说配置文件配置文件根据使用场景可以尝试多种格式，CSS的语法就是一种。 当时没太听明白，只是想想觉得类似XML\HTML这种树形结构的数据应该都可以用CSS的语法(主要是选择器的特性)来进行配置的。&lt;/p&gt;

&lt;p&gt;继续说CSS本身，我所看到的设置样式的方式大概有两种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过预先配置的css文件来设置样式。&lt;/p&gt;
&lt;/li&gt;

&lt;li&gt;
&lt;p&gt;通过js修改dom属性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然而第二种并不是全局有效的，我觉得不能算是配置。&lt;/p&gt;

&lt;p&gt;其实还有一种应该也是在入门的时候就有的概念，就是直接写&lt;strong&gt;embedded-style-sheet(嵌套样式表，页内样式表)&lt;/strong&gt;的css来达到一种脚本化CSS的效果，但与直接改dom属性相比，这个是全局有效的。&lt;/p&gt;

&lt;p&gt;在传统的网页上，直接修改元素的样式很方便，也没什么问题。但是到WebApp上，由于需要屏幕适配，并且有大量元素的增删操作， 单纯依靠Fluid Layout或者media queries不一定能解决问题。 于是就看到了很多在元素创建之后的element style设置。&lt;/p&gt;

&lt;p&gt;如果在每次创建的时候设置还不是大问题，那么当窗口大小变化的时候，还是会碰到问题。因为这有一个全局感知resize，计算新样式并向下通知的过程。设计的好，这应该是个自顶向下的流程，否则可能就乱了。&lt;/p&gt;

&lt;p&gt;然而如果创建一个embedded-style-sheet去维护这些配置，问题就简单了。&lt;/p&gt;

&lt;p&gt;于是做了个叫DCSS的东西，比较简单，轻拍。 &lt;a href='https://github.com/houkanshan/dcss'&gt;https://github.com/houkanshan/dcss&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;主要接口是Dcss.rule()，实现了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rule(&amp;#39;.selector&amp;#39;)

rule(&amp;#39;.selector&amp;#39;, &amp;#39;color&amp;#39;)

rule(&amp;#39;.selector&amp;#39;, &amp;#39;color&amp;#39;, &amp;#39;black&amp;#39;)

rule(&amp;#39;.selector&amp;#39;, {&amp;#39;color&amp;#39;: &amp;#39;black&amp;#39;, &amp;#39;background&amp;#39;:&amp;#39;white&amp;#39;})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前两个是getter, 后面是setter.&lt;/p&gt;

&lt;p&gt;还有一个没做：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rule({&amp;#39;.selector1&amp;#39;: {&amp;#39;color&amp;#39;: &amp;#39;black&amp;#39;, &amp;#39;background&amp;#39;:&amp;#39;white&amp;#39;}, &amp;#39;.selector2&amp;#39;:{&amp;#39;color&amp;#39;:&amp;#39;blue&amp;#39;}})&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外还有json2css, css2json两个接口&lt;/p&gt;

&lt;p&gt;发现一个响应式实现中的可能碰到的问题就是，所有的响应式都是先resize再render的，在resize和render之间元素还是会保持原来的样式， 如果这个时候是窗口缩小，而页面布局的时候没有留下这个缓冲空间，就会出现一次抖动(主要是对float和inline这种自适应方式的)。 代码里的index.html里面就出现了这种情况。&lt;/p&gt;

&lt;p&gt;然后打算过几天，把DianTv2的代码改一下~ 不过那个比较简单，有问题也看不出来。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;关于json &amp;amp; css的互转，还有一个实现： &lt;a href='https://github.com/aramkocharyan/CSSJSON'&gt;https://github.com/aramkocharyan/CSSJSON&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;很好奇的测试了下几种字符串分割的效率问题。&lt;/p&gt;

&lt;p&gt;&lt;a href='http://jsperf.com/string-split-houkanshan'&gt;http://jsperf.com/string-split-houkanshan&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;结果是性能上：split(string)&amp;#160;&amp;#187; match(regexp) &amp;gt; split(regexp)&amp;#160;&amp;#187; regexp.exec(string)&lt;/p&gt;

&lt;p&gt;&lt;img alt='split test' src='https://docs.google.com/drawings/pub?id=1nSp_-WbH6E4oRfumYWKhSHNEc1qOMcIDDDEnn7yvgw8&amp;amp;w=930&amp;amp;h=466' /&gt;&lt;/p&gt;

&lt;p&gt;测试的时候考虑的主要是平常的用法，应为exec的循环方法不一样，所以加上了循环，并没有做什么优化，本来期望的是差异不大的。 但结果是，能用split分割的时候尽量用split(string)，不行的话就用match，再不行的话才用exec。&lt;/p&gt;

&lt;p&gt;而这个实现用的是最慢的exec+递归，优势是他能支持media选择器，也就是多层规则。但是我不需要， 我只要能实现一个类似$.css()的方法就行了，因此直接用了split套两层循环实现。&lt;/p&gt;

&lt;p&gt;正则虽然很猛，熟练了估计会很无敌。但应用中还是要看场合，字符串分割我觉得就没必要了，而且对我这种菜鸟要读正则太耗时了。。。&lt;/p&gt;

&lt;p&gt;（不过已经几次笔试的时候碰到正则的大题了，做的都不怎么样，囧）&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;今天真是个神奇的日子。&lt;/p&gt;

&lt;p&gt;早上赶去参加某公司的面试，一开始自我介绍就自曝说转前端半年，于是就有点被bs的感觉，后来面试官哥哥(叔叔?)问我是不是主要写JS，我补充说还写CSS的。&lt;/p&gt;

&lt;p&gt;的。。。&lt;/p&gt;

&lt;p&gt;然后就看到他一脸很无语的感觉。于是我也满脸黑线了，开始怀疑我是不是投错岗位了。。。 毕竟我觉得我应该是个CSS\JS各一半，设计\网络各一半，后端1/5的人的(数学不好&amp;#8230;算不清)&lt;/p&gt;

&lt;p&gt;总之又是一次很没感觉的面试，很多该说的地方表现的太含蓄了。。。&lt;/p&gt;

&lt;p&gt;回来收到小kk豆油的问我豆瓣的情况~ 然后还不停安慰我。忍不住翻出一张旧照片看了一阵，唔，真好。&lt;/p&gt;

&lt;p&gt;&lt;img alt='旧照片' src='https://docs.google.com/drawings/pub?id=1UiYFbsChBatVkMondOCaWeXIHzwVA61uKCdP-12d3tY&amp;amp;w=545&amp;amp;h=100' /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;旧照片&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;后来发现饭卡掉了，这对一个死宅来说真是不容易。嗯，可能是在某公司面试前坐地上看书的时候掉的。 希望是一个武大的孩子捡到我的饭卡，这样应该就可以省20块钱了~ 华师也行~ 地大也行~&lt;/p&gt;

&lt;p&gt;后来我爸和我妈相继来电话，都跟我说&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;即使去不了某植物公司没关系，还是要尽力争取去某动物公司&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;而奇怪的地方就在于，以他们为首的我的所有家人，之前都是要我去保研的~&lt;/p&gt;

&lt;p&gt;其实也不奇怪，是吧。&lt;/p&gt;

&lt;p&gt;晚上渴的不行，又不巧手边是瓶没喝完的咖啡，更不巧的是我明天要交一堆不想做的设计，接下来就该去windows打开PS然后等太阳了。&lt;/p&gt;

&lt;p&gt;谢谢各位。&lt;/p&gt;

&lt;p&gt;以上，请指责。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>关于scss</title>
   <link href="http://houkanshan.github.com/2012/10/06/about-scss"/>
   <updated>2012-10-06T00:00:00+08:00</updated>
   <id>http://houkanshan.github.com/2012/10/06/about-scss</id>
   <content type="html">&lt;p&gt;为什么要写博客呢。。。因为我发现其实写的时候才是在认真总结啊~ 这是个利用自己的虚荣心学习的机会。。。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;关于scss(sass)我觉得它比less也就好用个100倍的样子吧~&lt;/p&gt;

&lt;p&gt;嗯，其实就是上次说的&lt;a href='http://houkanshan.github.com/2012/08/11/bootstrap-less/'&gt;less的缺点&lt;/a&gt;，scss基本没有。。&lt;/p&gt;

&lt;p&gt;不过有个不足就是scss没有名字空间的用法。其实也无所谓，用 %xxx 这样的伪选择器代替就可以了~&lt;/p&gt;

&lt;p&gt;我超喜欢他的@extend（&lt;a href='http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#extend'&gt;doc&lt;/a&gt;）6， 因为他会将所有用了@extend的选择器放一起写，这样可以减掉很多冗余的代码。类似：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.a {font:red}
.b {@extend .a}
.c {@extend .b}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.a, .b, .c {font:red}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样去做，处理那些重用次数很多的hide, bfc, pull-left/right等样式组件以及重用量大的模块，就能省掉很多代码了~ （是不是有点强迫症 = =?）&lt;/p&gt;

&lt;p&gt;然后发现一个很可能是严重的问题，假设页面中有40个元素要hide，如果这样用的话，就会出现。。。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.a, .b, ...好累啊不写了..., .at, .au { display:none; }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;感觉好恐怖啊，首先想到的是会不会影响效率，你想一个元素a的样式，一下在这里声明，一下在那里声明(我要看css样式计算和渲染的算法！哪里有？)&lt;/p&gt;

&lt;p&gt;于是做了个测试。一个是500个元素的样式分散的声明（test1）( &lt;a href='https://github.com/houkanshan/test-demo/blob/gh-pages/css-render-test/test1.css'&gt;css&lt;/a&gt;, &lt;a href='https://github.com/houkanshan/test-demo/blob/gh-pages/css-render-test/scss/test1.scss'&gt;scss&lt;/a&gt; )， 另一个是500个元素的样式独立的声明（test2）( &lt;a href='https://github.com/houkanshan/test-demo/blob/gh-pages/css-render-test/test2.css'&gt;css&lt;/a&gt;, &lt;a href='https://github.com/houkanshan/test-demo/blob/gh-pages/css-render-test/scss/test1.scss'&gt;scss&lt;/a&gt; )&lt;/p&gt;

&lt;p&gt;测试结果是：&lt;/p&gt;

&lt;h4 id='test1'&gt;test1&lt;/h4&gt;

&lt;p&gt;&lt;a href='http://houkanshan.github.com/test-demo/css-render-test/test1.html'&gt;页面在此&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt='test1' src='https://docs.google.com/drawings/pub?id=1VubjFo4T0RL3eQr460iGnRlPYx9EEHtKAkgmdxokB_g&amp;amp;w=688&amp;amp;h=298' /&gt;&lt;/p&gt;

&lt;h4 id='test2'&gt;test2&lt;/h4&gt;

&lt;p&gt;&lt;a href='http://houkanshan.github.com/test-demo/css-render-test/test2.html'&gt;页面在此&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt='test2' src='https://docs.google.com/drawings/pub?id=1tEK6Iufvobo9YMZ-S-PGMa4bt6GFiOXwKwQ6UeIB0Nk&amp;amp;w=688&amp;amp;h=302' /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，分散声明(test1)只是在recalcute上时间比独立声明(test2)要长，而test2主要落后在下载上，而且注意我这还只是本地测试~&lt;/p&gt;

&lt;p&gt;所以用@extend应该是不用担心在性能上的问题了~ 不过在F12调试的时候会比较囧， 去掉某个属性(比如hide)前面的勾勾的时候可能就把其他的全都取消了(之前被hide的全都显示出来了)。。。&lt;/p&gt;

&lt;p&gt;嗯，scss的另一个特点(可能的问题?)就是他的伪选择器（@extend-Only Selectors），Begin with %&lt;/p&gt;

&lt;p&gt;比如说：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;%mod { height: 20px; width: 20px; }
.a { @extend %mod; }
.b { @extend %mod; }

.c {
    %mod {
        background: $dddddd;
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果吧%mod换成.mod，一切都很好说，但因为%mod是不会输出的，所以 .c %mod 这样的选择器就被换成了&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.c .a, .c .b { ... }&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而以后每次对%mod内容的增加，只要是涉及不同的选择器规则，就会成倍的输出选择器了耶~&lt;/p&gt;

&lt;p&gt;虽然之前都说性能影响不是很大，但是就跟coffeescript一样，我觉得过度依赖预处理技巧输出代码的问题就在于调试。&lt;/p&gt;

&lt;p&gt;欣赏一下！&lt;/p&gt;

&lt;p&gt;&lt;img alt='mass css selector' src='https://docs.google.com/drawings/pub?id=1hYLG2o46FDSoSqS9MeWeH4ecLi0p0qxWSEBI3gcIj74&amp;amp;w=346&amp;amp;h=213' /&gt;&lt;/p&gt;

&lt;p&gt;嗯，也不能随便下定论，先试试，看到底调试的问题大不大。。。&lt;/p&gt;

&lt;p&gt;以上，请指责。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>关于DianTv</title>
   <link href="http://houkanshan.github.com/2012/10/05/about-diantv"/>
   <updated>2012-10-05T00:00:00+08:00</updated>
   <id>http://houkanshan.github.com/2012/10/05/about-diantv</id>
   <content type="html">&lt;p&gt;（对了，不知道这里的图能不能在局域网显示，因为都是放在google doc上的，东西还是要放一起的好）&lt;/p&gt;

&lt;p&gt;&lt;img alt='DianTv' src='https://docs.google.com/drawings/pub?id=1bjQG8XPz1RAE5dRQ7BfShonpmfyNqvTQzsbmVUtVJn0&amp;amp;w=959&amp;amp;h=528' /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href='https://github.com/houkanshan/DianTv'&gt;DianTv&lt;/a&gt;最初就是图里这个土东西。 简单的用Meteor写的东西，分量个端，一个是在电梯屏幕上打开的页面，另一个是其他电脑上 打开的。两个最大的不同就是一个可以编辑，而另一个不行。&lt;/p&gt;

&lt;p&gt;可是我不喜欢用Meteor&amp;#8211;总是不知道这样做会发生什么，也许是我接触的编程思想太少。 Meteor很酷，理念也很酷，可是我不想用它。如果要开始去理解一个框架，Meteor感觉还不适合。&lt;/p&gt;

&lt;p&gt;于是就有了下面所示的另一个土东西，&lt;a href='https://github.com/houkanshan/DianTv2'&gt;DianTimes (DianTv2.0)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt='DianTv2' src='https://docs.google.com/drawings/pub?id=14aRS_iuU-6cRe_EcPARQ_jIAwYakJXY8PCZDa1Xd1jg&amp;amp;w=959&amp;amp;h=528' /&gt;&lt;/p&gt;

&lt;p&gt;一个特点是可以直接在显示的内容上编辑，编辑后保存直接显示效果，没有再次加载的过程~&lt;/p&gt;

&lt;p&gt;(= =!)好吧。虽然换了个洋气的称呼还是不改他土的本质。DianTv从开始弄到让他上线大概花了一个礼拜，这个2从后台restful到前端完成居然花了1个月 (不对，其实前端的主要代码还是上个礼拜在90House弄的)！&lt;/p&gt;

&lt;p&gt;其实把代码拿掉外部的厍也就1.5K多的样子。。。原因主要除了编码能力弱外，还有就是折腾的东西有点多，肯定是过度设计了的。&lt;/p&gt;

&lt;p&gt;&lt;img alt='framework' src='https://docs.google.com/drawings/pub?id=1AZHespKey-Wr9kFdbz-IxjzsfRG3bJVQDKfvgS3ZlJQ&amp;amp;w=1732&amp;amp;h=1133' /&gt;&lt;/p&gt;

&lt;p&gt;我一开始脑袋里就在想这个图，还觉得很美好。其实呢，呵呵。（虚线是继承关系，实线是依赖关系，点线是消息流，最上面是全局依赖）&lt;/p&gt;

&lt;p&gt;最纠结的还是&lt;strong&gt;Pub/Sub&lt;/strong&gt;（不要笑我！），一开始实在不知道这个看起来很好的东西该怎么用。&lt;/p&gt;

&lt;p&gt;用一个全局的总线来广播把，怕效率低，更怕结构乱。 每个模块独立进行事件分发吧，又觉得其实就是调用关系，犯不着trigger(pub)一下，而且用多了调试起来很麻烦。(我觉得我是被一些教程误导了)&lt;/p&gt;

&lt;p&gt;纠结了很久决定主要用pub/sub主要处理异步事件。大概是这样&amp;#8230;&lt;/p&gt;

&lt;p&gt;&lt;img alt='pubsub' src='https://docs.google.com/drawings/pub?id=1ay4G7v8j7XICMj6AwzuTK552giuCpneFCzA_06C85R4&amp;amp;w=440' /&gt;&lt;/p&gt;

&lt;p&gt;直接调用最麻烦的还是异步/同步的问题，用pub/sub来解决。这个图主要是利用一条消息总线来连接不同模块， 每个模块&lt;strong&gt;不直接依赖&lt;/strong&gt;其他模块，只需要一条消息总线， 并且&lt;strong&gt;屏蔽同步异步的差异&lt;/strong&gt;, 每个模块自己需要处理的异步事件只是服务器连接、用户事件、模块功能调用。&lt;/p&gt;

&lt;p&gt;实际上是把对其他模块的调用也当作一次服务器调用了，极端点的说不定还可以让核心模块提供一个类似URI格式的api (= =!) ，比如:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Event.bind(&amp;#39;res://people/houkanshan?type=get&amp;#39;, this.kiss.bind(this));
Event.trigger(&amp;#39;req://people/houkanshan?type=get&amp;#39;);&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id='spinejs'&gt;Spine.js&lt;/h3&gt;

&lt;p&gt;这个核心代码(js)大概900行，但是我好像最多只用了400行。他的model类基本没有用上。而且我觉得实际上他的模块继承达不到要求啊。&lt;/p&gt;

&lt;p&gt;还有我发现spine现在的代码，应该是已经跑不了&lt;em&gt;javascript web application&lt;/em&gt;这本书里面的代码的了吧&amp;#8230; &amp;#8230;&lt;/p&gt;

&lt;h3 id='css3'&gt;CSS3动画&lt;/h3&gt;

&lt;p&gt;CSS3动画主要的特点就是流畅(这个在移动应用上很重要&lt;a href='http://dev.opera.com/articles/view/css3-vs-jquery-animations/'&gt;CSS3 vs jQuery Animations&lt;/a&gt;)， 而且可叠加(比如变大和变小可以同时使用，结果就是向量加法~)，&lt;/p&gt;

&lt;p&gt;但是CSS3动画有一个问题，就是他是异步的，我一开始以为要setTimeout来同步，越想越觉得不对，于是发现有animationend事件。。。 不过还是用animation.js还是用setTimeout写的，里面都是糊弄的。。。&lt;/p&gt;

&lt;p&gt;要实现复杂的动画效果，就有个动画的编排问题，比如ABC的消失顺序是&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;A(start)--------&amp;gt;A(done)
-----&amp;gt;B(start)-------------&amp;gt;B(done)
----------&amp;gt;C(start)------------------&amp;gt;C(done,callback)&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就能实现一个比较平滑的尤上至下的渐隐效果。如果是帧动画来实现的话，直接定帧的效果就可以了，但如果用css动画就麻烦了， 应该要用到promise和pubsub来处理这个。而且我觉得，处理的好，这种异步的动画会比帧动画更有编码上的优势。。&lt;/p&gt;

&lt;p&gt;我自己的都是瞎糊弄的，没啥。别的没有看，但我觉得Y大(&lt;a href='http://www.douban.com/group/Dexter_Yy/'&gt;http://www.douban.com/group/Dexter_Yy/&lt;/a&gt;) 的&lt;a href='http://dexteryy.github.com/OzJS/examples/animate/index.html'&gt;animate&lt;/a&gt;超帅。&lt;/p&gt;

&lt;p&gt;（好吧，都忘了wind.js了）&lt;/p&gt;

&lt;p&gt;另外css3动画要注意的是start状态和end状态的设置之间必须得有一次渲染过程，否则start被覆盖就直接就到end状态了，所以要用setTimeout(setEnd, 1)来等渲染。&lt;/p&gt;

&lt;p&gt;不过我还是没清楚渲染的时机是怎么决定的。。。&lt;/p&gt;

&lt;p&gt;以上，请指责。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>css状态选择器(杜撰物)</title>
   <link href="http://houkanshan.github.com/2012/09/30/css-status"/>
   <updated>2012-09-30T00:00:00+08:00</updated>
   <id>http://houkanshan.github.com/2012/09/30/css-status</id>
   <content type="html">&lt;p&gt;个人认为css的选择器标识分两类。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* 实体
    * 模块 .head-pic, .sub-btn, etc. 
    * 类  .btn, h1, etc.
    
* 状态 .enable, .disable, .has-img, .no-img, etc.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;像这个图一样，紫色的是状态，黑色的是实体。&lt;/p&gt;

&lt;p&gt;&lt;img alt='css-status' src='https://docs.google.com/drawings/pub?id=14Csv25-kgd-BKhudjE0UzYh64nO9iXVx4sFksNm2Muo&amp;amp;w=393&amp;amp;h=317' /&gt;&lt;/p&gt;

&lt;p&gt;实体标识就是放在所标识的标签上的~&lt;/p&gt;

&lt;p&gt;而状态标识 就应该作为一种&lt;strong&gt;配置选项&lt;/strong&gt;放在模块级别下的全局位置。 &lt;br /&gt;放在全局下的好处应该就是这样模块下的所有实体的状态是透明的；而且是可以统一读取； 更重要的是减少优先级混乱的可能，因为可以在同一个位置根据不同的状态配置不同的规则。&lt;/p&gt;

&lt;p&gt;当然，这样的问题是.pic在变成一个模块的时候就不方便再独立维护一个状态。这就需要仔细斟酌状态的应用范围了。&lt;/p&gt;

&lt;p&gt;虽然说上面图里面的情况只需要给.content用BFC就能解决问题。但是问题再复杂点呢？比如我要根据给.no-img情况下的.content用更大的字体?&lt;/p&gt;

&lt;p&gt;当然原则应该还是在模块级别上维护状态，如果pic形成独立的模块，还是得在.pic上加状态标识。&lt;/p&gt;

&lt;p&gt;不知道啊，以后再看看。。。&lt;/p&gt;

&lt;p&gt;以上，请指责。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>猜(关于css)</title>
   <link href="http://houkanshan.github.com/2012/08/19/module-css"/>
   <updated>2012-08-19T00:00:00+08:00</updated>
   <id>http://houkanshan.github.com/2012/08/19/module-css</id>
   <content type="html">&lt;p&gt;我今天要草率的把我的一些关于css的草率的想法和实践草率的写出来，所以就叫猜。&lt;/p&gt;

&lt;p&gt;我之前一直苦于我的css代码基本就是样式堆砌的丑陋代码。即使是分了reset, common, page也无济于事。&lt;/p&gt;

&lt;p&gt;less可以一定程度上避免代码的堆砌，因为它可以样式规则的嵌套。 但是样式规则嵌套不能过深，否则会导致选择器性能问题。&lt;/p&gt;

&lt;p&gt;增加逻辑层次是一个合理放置代码的解决办法，比如模块。当然模块的初衷显然不是为了解决css代码混乱的， 模块化的好处除了增加代码可读性外，更重要的是它具有可重用的能力。其实也算是代码规范的功劳了， 其实代码规范好的话，可以解决很多问题。我甚至觉得架构这个东西，就应该是用代码规范来解决的。。。&lt;/p&gt;

&lt;p&gt;基于less的css规范，我自己的实践原则是这样的，很简单：&lt;/p&gt;

&lt;h4 id='id2840'&gt;纵向上是&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;模块1(名字空间) {  /* 比如 .speak-dialog */
    类1;         /* 比如 h1,h2,h3 {} */
    类2;         /* 比如 .hd {} */
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模块从全局空间开始，按照html树的层级，下面可能就到aside,main这级，然后再细化到内部的模块。到不能再细分模块的时候就以传统的css写法写。 这种模块+类在html结构上应该象是这样：&lt;/p&gt;

&lt;p&gt;&lt;img alt='css module' src='https://docs.google.com/drawings/pub?id=1rg7vzagk78_arYcCxHUtzPCPwOOAiFJBiz7Wc_cM1XQ&amp;amp;w=457&amp;amp;h=263' /&gt;&lt;/p&gt;

&lt;h4 id='id2841'&gt;横向上是&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;[{layout, style}, {layout, style}, ...]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;layout包含会影响模块定位的属性，包括size,margin,border,float,position,padding,line-height,display等 (padding需要注意，因为当设置了width/height时，也padding会影响占位，所以虽然padding的语义是控制内容空间，但还是要放在布局的级别上)。 这些应该是对应render中的layout阶段的。&lt;/p&gt;

&lt;p&gt;style则是剩下的元素显示效果，对应render中的paint阶段。&lt;/p&gt;

&lt;h4 id='id2842'&gt;所以大体的顺序应该是：&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;全局名字空间的layout(nav,footer,header,section,main,aside,h1,h2,h3,h4等等的布局样式)&lt;/li&gt;

&lt;li&gt;全局名字空间的style(nav,footer,header,section,main,aside,h1,h2,h3,h4等等的效果样式)&lt;/li&gt;

&lt;li&gt;aside,main,nav,header,footer等模块的layout&lt;/li&gt;

&lt;li&gt;aside,main,nav,header,footer等模块的style&lt;/li&gt;

&lt;li&gt;aside内模块的layout&lt;/li&gt;

&lt;li&gt;aside内模块的style&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&amp;#8230;&lt;/p&gt;

&lt;p&gt;对于一些模块间共用的样式，可以单独抽离出来成为独立的模块放到全局环境中去&lt;/p&gt;

&lt;p&gt;乍看这样可能会写出很多重复的选择器，就比如layout和style或许没必要分这么开。但个人的实践中，layout和style的选择器的重复部分似乎并不大， 比如.a模块中设置了h1的layout，并不意味着就也要设置它的style，因为它已经继承了全局的设置了，所以单独再样式集内分离layout，style意义不大，还是需要在整体代码上分离开来。&lt;/p&gt;

&lt;p&gt;而且layout与style也是独立的，基本上写css都是先layout再style这个先繁后简的流程。&lt;/p&gt;

&lt;h3 id='css'&gt;关于css的其他想法&lt;/h3&gt;

&lt;h4 id='id2843'&gt;通用原子类？&lt;/h4&gt;

&lt;p&gt;http://book.douban.com/people/houkanshan/annotation/4881987/&lt;/p&gt;

&lt;p&gt;其实也看到一些同学这样做了。&lt;/p&gt;

&lt;p&gt;我是比较反对通过直接在html上加具有样式意义的class来修改html的样式的，尤其是在css预处理器出现之后。 这些工作完全可以在预处理阶段完成。说是开发上快速，其实没有什么区别。在html模板上修改样式会很爽么？&lt;/p&gt;

&lt;p&gt;更重要的就是破坏内容样式分离，有优先级被覆盖的问题，弄乱了html，也弄乱了css。&lt;/p&gt;

&lt;p&gt;即使是为了javascript处理交互效果时方便加class，也不应该这样做。最容易出现优先级的问题。 而且，既然做selected的时候用的是给selected单独css，为什么在设置浮动的时候又要用base里面的东西而不能直接多写一点样式呢？ 而且写在css里面就可以让人知道这个元素将来可能的表现了。&lt;/p&gt;

&lt;h3 id='id2844'&gt;嗯&lt;/h3&gt;

&lt;p&gt;一个做过前端的妹子某次问我最近再做什么，然后问我写css不无聊么。&lt;/p&gt;

&lt;p&gt;这真不好回答，其实我还想写点css，虽然最后编译出来的东西都是那么一坨。。。&lt;/p&gt;

&lt;p&gt;以上，请指责。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>bootstrap+less</title>
   <link href="http://houkanshan.github.com/2012/08/11/bootstrap-less"/>
   <updated>2012-08-11T00:00:00+08:00</updated>
   <id>http://houkanshan.github.com/2012/08/11/bootstrap-less</id>
   <content type="html">&lt;h3 id='id2835'&gt;两个感觉：&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;less不是个很好的东西 2. bootsrap结合less自己用着就挺好~&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id='less'&gt;less的缺点&lt;/h3&gt;

&lt;p&gt;自己偶尔发现的，所以肯定也不能说是致命缺点，但是在有诸多css扩展语言的环境下足以影响我对它的好感。。。&lt;/p&gt;

&lt;h4 id='id2836'&gt;输出代码冗余：&lt;/h4&gt;

&lt;p&gt;对于这样结构的less代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.class {
    /* some style */
}
.A {
    .class;
    /* other for A */
}
.B {
    .class;
    /* other for B */
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;直觉上就想到这样输出正好可以压缩：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.class, .A, .B {
    /* some style */
}

.A {
    /* other for A */
}
.B {
    /* other for B */
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然而less预处理器却非要把.class的样式重复三遍输出，纯写css可能还会注意点代码的复用，结果用less的时候想到可以用mixin结果反而比纯写css还多了些没必要的代码。&lt;/p&gt;

&lt;h4 id='import'&gt;import只支持同级目录&lt;/h4&gt;

&lt;p&gt;毕竟less是支持服务器和客户端编译的，或许很难在客户端应用上目录远程文件的目远程文件的目录结构，所以只能应用同级目录，然而除了调试估计也没谁会让浏览器去编译less， 这就给服务器上管理less文件带来一些麻烦。&lt;/p&gt;

&lt;h4 id='less'&gt;生成的类名不能在less中复用&lt;/h4&gt;

&lt;p&gt;碰到的情况是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@var: &amp;#39;css&amp;#39;;
(~&amp;quot; .compiled-@{var}&amp;quot;) {
    color: red;
}
.use-compiled-css {
    .compiled-css;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;只前4行输出的是.compiled-css{&amp;#8230;}，(测试的时候如果用客户端的方式编译就直接失败了。) 加上后面的东西后就编译失败。 碰到这个情况的时候本来是想把bootstrap的grid直接作为组件mixin在布局里面的，结果发现grid的span1~12是用代码生成的，这些样式集不能在less中复用。。。&lt;/p&gt;

&lt;h4 id='id2837'&gt;官方提供的预处理器太弱&lt;/h4&gt;

&lt;p&gt;其实上面的问题都出在预处理器上，官方给的预处理器只支持单个文件的单次编译，以bootstrap为例，要做到再linux上watch到reset.less文件的更改后编译boostrap.less输出bootstrap.css到上级目录， 目前似乎只能自己用node写脚本。。。&lt;/p&gt;

&lt;h4 id='mixin'&gt;mixin的做法容易造成选择器过长&lt;/h4&gt;

&lt;p&gt;我不知道 “body #nav ul li a” 这样的选择器会造成多大的性能影响，但这种总是可以避免的。&lt;/p&gt;

&lt;p&gt;而如果是用滥mixin就很有可能不经意就造成生成了这样的选择器。不过一般代码风格好的人都会注意控制嵌套层次，所以倒还不是大问题~&lt;/p&gt;

&lt;h3 id='bootstrap__less'&gt;bootstrap + less&lt;/h3&gt;

&lt;p&gt;意思是直接基于bootstrap的less版本开发，我还是觉得bootstrap的样式只适合开发原型，但是觉得它的reset.less(normalize.css), type.less, variables.less, mixins.less等都是很值得参考的less方案，而且它的grid系统也很好用，所以拿来自己用其实挺好的。&lt;/p&gt;

&lt;h4 id='bootstrapless'&gt;为什么用bootstrap的less？&lt;/h4&gt;

&lt;p&gt;因为它提供了一个less的厍，我觉的css往预处理器发展是必然的，什么oocss之类的解决方案都应该基于预处理器，css具有一定的编程性后就应该有一些厍出现，尽可能屏蔽浏览器差异，减少代码冗余，简化开发，样式内容分离。唉，听起来挺美好，也悲伤的。&lt;/p&gt;

&lt;p&gt;有些要注意的地方~&lt;/p&gt;

&lt;h4 id='id2838'&gt;哪些可以拿来用？&lt;/h4&gt;

&lt;p&gt;reset.less, variables.less, type.less, mixins.less可以直接用，也可以做适当裁剪，这里最有用的应该还是mixins.less, 把她们import了之后就可以在自定的样式里mixin了。另外bootstrap里Base CSS的部分也可以用，基于tabName的就没必要了。不要用Components里面的组件，因为她们大多是基于html上下文的，这样html的结构会受到css的限制，造成没必要的耦合。grids也用不了，这个主要是受less预处理器的限制，而且它也基于html上下文。&lt;/p&gt;

&lt;h4 id='id2839'&gt;文件组织和修改&lt;/h4&gt;

&lt;p&gt;single page app好说，所有文件全部import到一起输出一个css就好，网站的话就看这个网站的层级了。我的做法是合并了通常css文件中的reset和common，直接输出成一个全站的common文件。然后每个页面一个独立的css输出。&lt;/p&gt;

&lt;p&gt;在less的文件这一层，首先是reset模块，reset.less, type.less。这个编译出来基本就是一个常用的reset.css了&lt;/p&gt;

&lt;p&gt;然后是components模块，包括variables.less，mixins.less, 因为这个模块需要再很多文件里被import，所以要求单独编译这个模块不能产生css代码，也就是说里面的所有样式集都应该以Variables/Parametric Mixins的形式存在，所以需要对mixins做部分修改和删减。&lt;/p&gt;

&lt;p&gt;第三是需要用的bootstrap样式厍，比如buttons，forms，tables，需要的就可以直接import进入&lt;/p&gt;

&lt;p&gt;以上面两个模块为基础，首先是一个common.less：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* components(include variables.less, mixins.less) */
@import &amp;quot;components.less&amp;quot;;

/* reset */
@import &amp;quot;reset.less&amp;quot;;
@import &amp;quot;type.less&amp;quot;;

/* bootstrap style sets */
@import &amp;quot;tables.less&amp;quot;;
...

/* common style */
...&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后每种页面私有的样式集：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/* components(include variables.less, mixins.less) */
@import &amp;quot;components.less&amp;quot;;

/* page style */&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上，请指责。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>bootstrap读后感</title>
   <link href="http://houkanshan.github.com/2012/06/14/after-read-bootstrap"/>
   <updated>2012-06-14T00:00:00+08:00</updated>
   <id>http://houkanshan.github.com/2012/06/14/after-read-bootstrap</id>
   <content type="html">&lt;h3 id='id2833'&gt;文件内容&lt;/h3&gt;

&lt;h4 id='bootstrapless'&gt;bootstrap.less&lt;/h4&gt;

&lt;p&gt;编译入口，加载所有less文件&lt;/p&gt;

&lt;h4 id='resetless'&gt;reset.less&lt;/h4&gt;

&lt;p&gt;底层模块，基本没有less语法&lt;/p&gt;

&lt;p&gt;与YUI相比没有margin:0; padding:0, 有html5标签, 只处理了一部分浏览器的默认样式，主要跟据新的标准对移动设备上的表单做了reset, 因为实际上具体的样式已经在其他模块定义好了，所以这里只需要统一一些重要的样式和解决一些浏览器bug即可&lt;/p&gt;

&lt;h4 id='variablesless'&gt;variables.less&lt;/h4&gt;

&lt;p&gt;定义颜色，字体，icon，grid的配置变量&lt;/p&gt;

&lt;h4 id='mixinsless'&gt;mixins.less&lt;/h4&gt;

&lt;p&gt;定义基本样式单元，用于组合。包括基本布局(block-center, ie-inline-block), block形状，placeholder，text-overflow, 图片上hide-text, font-family, CSS3样式, 渐变背景样式，组件基本样式：nav-divide, button-bg, popoverArw, Grid, 一些组件在定义时声明了namespace （还有些看不懂要干嘛）&lt;/p&gt;

&lt;h4 id='scaffoldingless'&gt;scaffolding.less&lt;/h4&gt;

&lt;p&gt;29行，scaffolding听起来很吓人但其实这里只定义了body和a的样式&lt;/p&gt;

&lt;h4 id='gridless'&gt;grid.less&lt;/h4&gt;

&lt;p&gt;6行， 使用了mixins.less定义的grid组件中的.core和.fluid分别对应default grid system和fluid grid system.&lt;/p&gt;

&lt;h4 id='layoutless'&gt;layout.less&lt;/h4&gt;

&lt;p&gt;定义了.container 和 .container-fluid 一个是定宽，一个是fluid的&lt;/p&gt;

&lt;h4 id='typeless'&gt;type.less&lt;/h4&gt;

&lt;p&gt;用官方的话来说叫typography，算是排版？reset里没定义的h*, ul/ol, dl等都在这里设置了样式&lt;/p&gt;

&lt;h4 id='codeless'&gt;code.less&lt;/h4&gt;

&lt;p&gt;顾名思义了，这里不明白为什么block-code的样式用pre而不是code. 难道code标签只是用于inline-code的&lt;/p&gt;

&lt;p&gt;里面有个跨浏览器的pre样式，现在好像差不多都是这样写的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;white-space: pre;       /* for ie6, 空格\t\n有效，不会边界自动换行, 与pre标签效果类似 */
white-space: pre-wrap;  /* IE8, FF3.0, Opera8.0, Safari3.0, 加上了边界换行, 对non-CJK还是分词换行, CJK按字直接换行*/
word-break: break-all;  /* IE5+ 其他不清楚，对non-CJK在边界上直接字母间打断换行 */
word-wrap: break-word;  /* FF3.5, chrome1.0, IE5.5 Opera10.5, Safari1.0, non-CJK会优先分词换行，如果换行后还是超长，就会直接打断*/&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id='formless'&gt;form.less&lt;/h4&gt;

&lt;p&gt;表单样式，不是很想看。。。不要随便改懂就好。。。&lt;/p&gt;

&lt;h4 id='tableless'&gt;table.less&lt;/h4&gt;

&lt;p&gt;表格样式，还是使用了大量:first-child, :last-child选择器去控制&lt;/p&gt;

&lt;h4 id='utilitiesless'&gt;utilities.less&lt;/h4&gt;

&lt;p&gt;bootstrap.less里最后import的是这个，这里放了一些控制显示的组件，主要是用于js操作页面元素的。 之所以放最后应该是为了提升优先级，比如display:none/block，是很容易被优先级覆盖的。&lt;/p&gt;

&lt;p&gt;很多网站有一个base.css的文件，里面除了reset和基本样式外还放了left,right,hidden这样的控制组件 实际上在实际控制的时候会出现优先级不够导致属性被覆盖的问题。不知道他们是怎么处理这个的。&lt;/p&gt;

&lt;h4 id='other'&gt;other&lt;/h4&gt;

&lt;p&gt;剩下的sprites.less, dropdown.less, wells.less, component-animations.less, buttons.less, button-groups.less, alerts.less, nav.less等等都顾名思义了，都主要是样式的定义。 使用的技巧光看也看不出什么。。。&lt;/p&gt;

&lt;h3 id='id2834'&gt;感觉&lt;/h3&gt;

&lt;p&gt;其实平时用bootstrap也不多，一方面觉得它丑(我总是对很多东西有非常奇怪的审美，见谅。。。), 另一方面是不喜欢他的使用方式。 我并不指望用css工具厍的方式来完全屏蔽浏览器差异，bootstrap就没有做到，css更应该是模块化而不是组件化(我也不知道我在说什么，个人感觉这两者主要是粒度的差异)。 要想靠一个个class组合成一个效果局限性太大，我看过的用bootstrap作出来的网站，要么一看就知道是用bootstrap做出来的，要么只是用了它的一些布局组件和基本样式(button, table.etc)。 如果要bootstrap的样式与自定的样式混用的话，恐怕管理起来会很不方便，还不如全部自己写。毕竟css+html不是可执行代码，想把程序的复杂逻辑用在它上面是没有用的。&lt;/p&gt;

&lt;p&gt;bootstrap就拿来做原型吧，毕竟css+html是处在设计和代码之间的东西，不能单纯用两者中的某种思考方式去考虑css+html。&lt;/p&gt;

&lt;p&gt;以上，请指责。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>在本地同步两个代码版本库</title>
   <link href="http://houkanshan.github.com/2012/04/16/git-repo"/>
   <updated>2012-04-16T00:00:00+08:00</updated>
   <id>http://houkanshan.github.com/2012/04/16/git-repo</id>
   <content type="html">&lt;p&gt;很多人难免不得已用了两个系统，就像我这种什么都会点又什么都不会的类型。Windows上要做图、写Doc、调IE，反正多数是些非正业的事情，Linux上写代码。但是切换很麻烦，所有经常就顺便在Win上写了。本来是可以直接把代码放在Win的NTFS分区上两个系统都可以访问的，但是上次因为操作系统休眠的问题丢了代码(&lt;a href='http://xiaoxia.org/2011/07/29/linuxwindows-dual-system-of-sleep-function-almost-put-the-files-on-the-ntfs-lost'&gt;跟这个同学情况类似&lt;/a&gt;) ，就决定在两个系统上分别放代码了。&lt;/p&gt;

&lt;p&gt;一个同步的办法是用github，但是最近感觉开发中的代码最好还是不要没事就push一下，容易刷屏。但是要同步又必须是即时的，于是觉得应该可以直接在本地push/pull。&lt;/p&gt;

&lt;p&gt;git可以很方便的在本地push/pull而不需要daemon进程，直接git init &amp;#8211;bare就可以了。但这样创建的版本库只有.git目录，没有工作时的代码(working dir)。在上面用通常的方法做push/pull一类操作都会提示“This operation must be run in a work tree”&lt;/p&gt;

&lt;p&gt;开始是觉得一个git库因该是可以同时做Server和Client的，也就是在linux上往windows上的库直接push,尝试之后发现不行，因为在Client所有的push和pull都是主动的操作，Server都是被动接受的，同时一个Client是不应该有被动的行为的，所以也就是不能同时有两个角色。&lt;/p&gt;

&lt;p&gt;虽然可以通过一些很不正常的方法让server也获得代码并临时变成client再往远程push。但毕竟很丑陋。。。&lt;/p&gt;

&lt;p&gt;在NTFS上为了同步再加个repository，init为bare。在本地先push到这里，在有必要的时候再push到github上。&lt;/p&gt;

&lt;p&gt;&lt;img alt='示意图' src='/img/git-repo.png' /&gt;&lt;/p&gt;

&lt;p&gt;虽然有时候需要push两次，但是我觉得对于我这种情况，这的确是必要的步骤。&lt;/p&gt;

&lt;p&gt;git真灵活～赞美。。。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;又改了点样式，我表示这个主题是不是太烂了点啊。。。&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>人人插件:我从来都不发状态...</title>
   <link href="http://houkanshan.github.com/2012/04/14/dt_status"/>
   <updated>2012-04-14T00:00:00+08:00</updated>
   <id>http://houkanshan.github.com/2012/04/14/dt_status</id>
   <content type="html">&lt;p&gt;或者你可以把这个插件叫做:&amp;#8221;有一个腹黑的爹必有一个腹黑的儿子&amp;#8221;&lt;/p&gt;

&lt;p&gt;情况是这样的, 自从我进了某某实验室的某某项目组, 便在这个神奇的项目组种开始了我每天早上三四点入睡的闲适小日子. 直到有一天我爸给我来了个电话&amp;#8230;&lt;/p&gt;

&lt;p&gt;这让我多年以后我又一次感受到了父亲的威严 &amp;#8212;- 他看了我人人主页. (尽管我人人主页设置了最低的查看权限.)&lt;/p&gt;

&lt;p&gt;而我在当天的4点左右时间发了个很欢乐的状态. 但即使是最低的查看权限, 别人也能在你的个人主页看到你最近发的一条状态. 而我爸, 就是根据这条状态后面的&amp;#8221;12小时前&amp;#8221;推测出我欺骗了他! &amp;#8212;- 又熬夜了!&lt;/p&gt;

&lt;p&gt;而在此之前, 我也曾莫名奇妙的被我爸批评&amp;#8221;政治觉悟不高&amp;#8221;, 被我妈暗示&amp;#8221;失恋了也不能放弃生活&amp;#8221;, 被我爸误以为&amp;#8221;在团队有GF&amp;#8221;. 而这一切的一切, 都是因为我爸注册了个名叫&amp;#8221;王科学&amp;#8221;的太原女性马甲, 并时不时的访问我的人人主页.&lt;/p&gt;

&lt;p&gt;于是我终于不能忍受了. 除了把王科学拉黑并设置最低的访问权限外, 还需要解决最近的状态被暴露的问题.&lt;/p&gt;

&lt;p&gt;其实方法很简单, 发完一条状态A后, 再发一条状态B, 然后在把状态B删掉. 这样陌生人访问主页的时候, 最近的状态就变成&amp;#8221;什么也没做&amp;#8230;&amp;#8220;了. 非常好.&lt;/p&gt;

&lt;p&gt;于是做了这么个东西来实现这些步骤, 技术有限, 谨慎使用, just for fun.&lt;/p&gt;

&lt;p&gt;使用方法:&lt;/p&gt;

&lt;p&gt;1 点击进入后面的链接, 将页面里的链接拖到标签栏中, 这样就添加了一个书签. &lt;a href='http://houkanshandemo.sinaapp.com/dt_status/index.html'&gt;点我进入页面&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2 在人人主页发状态时, 在发状态的输入框中输入要发的状态, 不要点发送!&lt;/p&gt;

&lt;p&gt;3 这个时候直接点刚才的添加的书签, 根据你的网络状况, 可能要等待几秒. 这样就连发了两个状态, 并把最后一个状态删掉了~&lt;/p&gt;

&lt;p&gt;新旧版人人应该都支持, chrome和firefox应该都支持, ie的老版本好像有书签地址长度限制，估计不行&amp;#8230;嗯.&lt;/p&gt;

&lt;p&gt;代码：&lt;a href='https://gist.github.com/2376278'&gt;https://gist.github.com/2376278&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;写在人人日志之外，&lt;/p&gt;

&lt;p&gt;我不是很清楚我现在的难过到底应不应该，我知道其实‘难过’不过是生活的一个过程没什么大不了的。但我究竟该不该放任这种难过的感觉呢。。。&lt;/p&gt;

&lt;p&gt;不知道。呵呵。。。&lt;/p&gt;

&lt;p&gt;for douban_9: doubanclaim9e4ffc21fdf7b0e3&lt;/p&gt;</content>
 </entry>
 
 <entry>
   <title>终于换了个博客</title>
   <link href="http://houkanshan.github.com/2012/04/06/helloworld"/>
   <updated>2012-04-06T00:00:00+08:00</updated>
   <id>http://houkanshan.github.com/2012/04/06/helloworld</id>
   <content type="html">&lt;p&gt;这阵子情绪波动较大，算下来在不同地方都连写三四篇博客了，不过都与技术无关。在机场的时候又把kejun的博客扫了几页，还是觉得我太弱了。估计这会儿再拼的一把也去不了豆瓣的。。。&lt;/p&gt;

&lt;p&gt;回到博客上，觉得可能要重新开始写博客，虽然写的东西应该还会很弱，但还是觉得大二那会写了用博客总结了点东西后提升还是蛮多的。&lt;/p&gt;

&lt;p&gt;随便找了个模板，打算粉下豆瓣，结果发现模板很是一般。。。还不如重写。。。然后随便改了下，就这样，好像还行。。。 原来博客的东西太弱，而且跟现在的方向不搭，就不迁了。&lt;/p&gt;</content>
 </entry>
 
 
</feed>