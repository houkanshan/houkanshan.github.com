<!-- _layout.jade--><!DOCTYPE html><html lang="en"><head><title>Houkanshan’s Blog</title><!-- TODO: meta--><link rel="stylesheet" href="/css/index.css"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" user-scalable="no"><link href="/css/post.css" rel="stylesheet"></head><body class="theme-modern"><header id="post-header" class="minor-header"><div class="header-wrapper"><h1 class="blog-title"><a href="/" title="Home">Houkanshan’s Blog</a></h1><nav id="blog-header-nav"><ul><li><a href="/posts/" title="Posts" class="nav-item">Posts</a></li><li><a href="/about/" title="About" class="nav-item">About</a></li></ul></nav></div></header><article id="post-content"><header id="post-content-header"><h2>about-scss</h2></header><article class="article-content"><p>为什么要写博客呢。。。因为我发现其实写的时候才是在认真总结啊~ 这是个利用自己的虚荣心学习的机会。。。</p>
<hr>
<p>关于scss(sass)我觉得它比less也就好用个100倍的样子吧~</p>
<p>嗯，其实就是上次说的<a href="http://houkanshan.github.com/2012/08/11/bootstrap-less/">less的缺点</a>，scss基本没有。。</p>
<p>不过有个不足就是scss没有名字空间的用法。其实也无所谓，用 %xxx 这样的伪选择器代替就可以了~</p>
<p>我超喜欢他的@extend（<a href="http://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#extend">doc</a>）6，
因为他会将所有用了@extend的选择器放一起写，这样可以减掉很多冗余的代码。类似：</p>
<pre><code>.a {font:red}
.b {@extend .a}
.c {@extend .b}
</code></pre><p>输出：</p>
<pre><code>.a, .b, .c {font:red}
</code></pre><p>这样去做，处理那些重用次数很多的hide, bfc, pull-left/right等样式组件以及重用量大的模块，就能省掉很多代码了~ （是不是有点强迫症 = =?）</p>
<p>然后发现一个很可能是严重的问题，假设页面中有40个元素要hide，如果这样用的话，就会出现。。。</p>
<pre><code>.a, .b, ...好累啊不写了..., .at, .au { display:none; }
</code></pre><p>感觉好恐怖啊，首先想到的是会不会影响效率，你想一个元素a的样式，一下在这里声明，一下在那里声明(我要看css样式计算和渲染的算法！哪里有？)</p>
<p>于是做了个测试。一个是500个元素的样式分散的声明（test1）(
<a href="https://github.com/houkanshan/test-demo/blob/gh-pages/css-render-test/test1.css">css</a>, 
<a href="https://github.com/houkanshan/test-demo/blob/gh-pages/css-render-test/scss/test1.scss">scss</a>
)，
另一个是500个元素的样式独立的声明（test2）(
<a href="https://github.com/houkanshan/test-demo/blob/gh-pages/css-render-test/test2.css">css</a>, 
<a href="https://github.com/houkanshan/test-demo/blob/gh-pages/css-render-test/scss/test1.scss">scss</a>
)</p>
<p>测试结果是：</p>
<h4 id="test1">test1</h4>
<p><a href="http://houkanshan.github.com/test-demo/css-render-test/test1.html">页面在此</a></p>
<p><img src="https://docs.google.com/drawings/pub?id=1VubjFo4T0RL3eQr460iGnRlPYx9EEHtKAkgmdxokB_g&amp;w=688&amp;h=298" alt="test1"></p>
<h4 id="test2">test2</h4>
<p><a href="http://houkanshan.github.com/test-demo/css-render-test/test2.html">页面在此</a></p>
<p><img src="https://docs.google.com/drawings/pub?id=1tEK6Iufvobo9YMZ-S-PGMa4bt6GFiOXwKwQ6UeIB0Nk&amp;w=688&amp;h=302" alt="test2"></p>
<p>可以看到，分散声明(test1)只是在recalcute上时间比独立声明(test2)要长，而test2主要落后在下载上，而且注意我这还只是本地测试~</p>
<p>所以用@extend应该是不用担心在性能上的问题了~ 不过在F12调试的时候会比较囧，
去掉某个属性(比如hide)前面的勾勾的时候可能就把其他的全都取消了(之前被hide的全都显示出来了)。。。</p>
<p>嗯，scss的另一个特点(可能的问题?)就是他的伪选择器（@extend-Only Selectors），Begin with %</p>
<p>比如说：</p>
<pre><code>%mod { height: 20px; width: 20px; }
.a { @extend %mod; }
.b { @extend %mod; }

.c {
    %mod {
        background: $dddddd;
    }
}
</code></pre><p>如果吧%mod换成.mod，一切都很好说，但因为%mod是不会输出的，所以 .c %mod 这样的选择器就被换成了</p>
<pre><code>.c .a, .c .b { ... }
</code></pre><p>而以后每次对%mod内容的增加，只要是涉及不同的选择器规则，就会成倍的输出选择器了耶~</p>
<p>虽然之前都说性能影响不是很大，但是就跟coffeescript一样，我觉得过度依赖预处理技巧输出代码的问题就在于调试。</p>
<p>欣赏一下！</p>
<p><img src="https://docs.google.com/drawings/pub?id=1hYLG2o46FDSoSqS9MeWeH4ecLi0p0qxWSEBI3gcIj74&amp;w=346&amp;h=213" alt="mass css selector"></p>
<p>嗯，也不能随便下定论，先试试，看到底调试的问题大不大。。。</p>
<p>以上，请指责。</p>
</article></article><footer id="post-footer" class="main-footer"><div class="footer-wrapper"><nav id="blog-footer-nav"><ul><li><a href="/posts/" title="Posts" class="nav-item">Posts</a></li><li><a href="/about/" title="About" class="nav-item">About</a></li></ul></nav></div></footer><script src="js/core.js"></script><script src="/js/post.js"></script></body></html>